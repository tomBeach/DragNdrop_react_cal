// ======= database data structures ========
sessionData = {
    session_id:1,
    room_id: 1,
    session_title: "session_title_1",
    session_start: "2018-10-02 09:00:00",
    room_name: "R100",
    sequences: [
        { seq: 1, abs: 11, title: "abs_title_1" },
        { seq: 2, abs: 22, title: "abs_title_2" },
        { seq: 3, abs: 33, title: "abs_title_3" }
    ]
}
@calendar_data = [dates, room_names, timeslots, session_seq_array]


// ======= session data structures ========
cellDataObj.1_1 = { id:null, addr:"1_1", cellType:"emptyCell", sessionData:null }


// ======= combined data structures ========
cellDataObj.1_1 =
{
    id: null,
    addr: "1_1",
    cellType: "sessionCell",
    sessionData: {
        session_id:1,
        room_id: 1,
        session_title: "session_title_1",
        session_start: "2018-10-02 09:00:00",
        room_name: "R100",
        sequences: [
            { seq: 1, abs: 11, title: "abs_title_1" },
            { seq: 2, abs: 22, title: "abs_title_2" },
            { seq: 3, abs: 33, title: "abs_title_3" }
        ]
    }
}
cellDataObj.1_1 = { id: null, addr: "1_1", cellType: "sessionCell", sessionData: sessionData }
sessionData = {
    session_id:1,
    room_id: 1,
    session_title: "session_title_1",
    session_start: "2018-10-02 09:00:00",
    room_name: "R100",
    sequences: [
        { seq: 1, abs: 11, title: "abs_title_1" },
        { seq: 2, abs: 22, title: "abs_title_2" },
        { seq: 3, abs: 33, title: "abs_title_3" }
    ]
}


// ======= application state tree structure =======
{
    dates: [],
    times: [],
    rooms: [],
    sessions: [],
    roomtimes: [],
    gridCells: [
        {
            1_1: {
                addr:"1_1",
                cellType:"sessionCell",
                x:100,
                y:100,
                w:100,
                h:22,
                sessionData: {
                    id: 1,
                    seq: 1,
                    title: "Session Title"
                }
            }
        },
        { ... }
    ]
}

dragStates = {
    dragXYWH: {x: 92.828125, y: 25, w: 189.015625, h: 22},
    gridXYWH: {x: 86.828125, y: 120, w: 791.46875, h: 480},
    mouseXY: {x: 0, y: 0},
    relXY: {x: 0, y: 0},
    dragging: false,
    scrolling: false,
    scrollStart: 0
}

======= component data storage =======
<Provider
    store={store}>
    <App />
</Provider>

// == add database data for dates, times, rooms, sessions; init start/target cells
App (
    <Grid
        dates=          {dates}
        times=          {times}
        rooms=          {rooms}
        sessions=       {sessions}
        startCellId=    {"2_1"}
        targetCellId=   {"2_1"}
        dragStates=     {dragStates}
        cellDataObj=    {null}
    />
)

// == data required for moving dragger within boundaries
let dragStates = {
    gridXYWH:       { x:0, y:0, w:0, h:0 },
    dragXYWH:       { x:0, y:0, w:0, h:0 },
    mouseXY:        { x:0, y:0 },
    relXY:          { x:0, y:0 },
    dragging:       false,
    scrolling:      false,
    scrollStart:    0
};

<Dragger
    id:             props.id,                   // init: "initDragger", active: "dragger1"
    text:           props.text,                 // session_title
    startCellId:    props.startCellId,          // "2_1"
    targetCellId:   props.targetCellId,         // "2_1"
    startCellData:  props.startCellData,        // init: null, active: cellDataObj("2_1")
    gridXYWH:       { x:0, y:0, w:0, h:0 },     // from store
    dragXYWH:       { x:0, y:0, w:0, h:0 },     // from store
    mouseXY:        { x:0, y:0 },               // from store
    relXY:          { x:0, y:0 },               // from store
    dragging:       false,                      // from store
    scrolling:      false,                      // from store
    scrollStart:    0                           // from store
/>


======= component data storage (original) =======
<Provider store={store}>
    <App />
</Provider>,

const App = () => (
    <div>
        <Grid
            dates=          {dates}
            times=          {times}
            rooms=          {rooms}
            sessions=       {sessions}
            dragStates=     {null}
            cellDataObj=    {null}
            startCellId=    {"2_1"}
            targetCellId=   {"2_1"}
        />
    </div>
);

let dragStates = {
    gridXY:         { x:0, y:0 },
    gridWH:         {w:0, h:0 },
    dragXY:         { x:0, y:0 },
    dragWH:         { w:0, h:0 },
    mouseXY:        { x:0, y:0 },
    relXY:          { x:0, y:0 },
    scrollStart:    0,
    dragging:       false,
    scrolling:      false
};

<Dragger
    id:             props.id,
    text:           props.text,
    timeslots:      props.timeslots,
    roomnames:      props.roomnames,
    scrollStart:    0,
    dragging:       false,
    scrolling:      false,
    cellDataObj:    null,
    cellIdsArray:   null,
    startCellId:    props.startCellId,
    targetCellId:   props.targetCellId,
    startCellData:  props.startCellData,
    gridxy:         props.gridxy,
    gridwh:         props.gridwh,
    dragxy:         props.dragxy,
    dragwh:         props.dragwh,
    mousexy:        { x:0, y:0 },
    relXY:          { x:0, y:0 }
/>




======= data flow =======
• call an action (e.g. store.dispatch(addDates))
    - can be called from anywhere in app (e.g. components, XHR callbacks, at scheduled intervals...)
    - examples

    { type: 'LIKE_ARTICLE', articleId: 42 }
    { type: 'FETCH_USER_SUCCESS', response: { id: 3, name: 'Mary' } }
    { type: 'ADD_TODO', text: 'Read the Redux docs.' }

• The Redux store calls the reducer function you gave it.
    - store will pass two arguments to the reducer
        the current state tree
        the action
    - a reducer is a pure function: it only *computes* the next state

• The root reducer may combine the output of multiple reducers into a single state tree.
    - When you emit an action, combined reducers returned by combineReducers() will call both reducers
    - it combines both sets of results into a single state tree

• The Redux store saves the complete state tree returned by the root reducer
    - This new tree is now the next state of your app
    - every listener registered with store.subscribe(listener) will now be invoked
    - listeners may call store.getState() to get the current state

======= dispatching actions =======
• Actions are executed in a strict order, so no race conditions occur
• container components can dispatch actions
• a function called mapDispatchToProps() can also dispatch actions
    - receives the dispatch() method
    - returns callback props that are injected into the presentational component
    - example:

    const mapDispatchToProps = dispatch => {
        return {
            onTodoClick: id => {
                dispatch(toggleTodo(id))
            }
        }
    }

======= reducers =======
• Create a new state, given the current state and an action
• Can act on all or part of the state
• Can be combined and reused
• Centralize data mutations
• A reducer is a pure function that takes the previous state and an action, and returns the next state.
    (previousState, action) => newState

• multiple reducers can handle different sub-states
    - example: content sub-state
    - defined by contentReducer.js
    - handles anything to do with app data associated with "content"
    - the sideMenu sub-state handles anything to do with sideMenu functionality

• start by specifying the initial state (first time through Redux will call the reducer with an undefined state)
    const initialState = {
        dates: [],
        times: [],
        rooms: [],
        sessions: [],
        roomtimes: [],
        gridCells: []
    };

• Syntax for copying current state and adding next state:
    (previousState, action) => newState
    return { ...state, ...newState }
    return { ...state, times: [...state.times, action.payload] };   // times value of state becomes value of action.payload

• All actions required:
    ADD_TIMES
    ADD_DATES
    ADD_ROOMS
    ADD_SESSIONS
    ADD_ROOTIMES
    ADD_CELLDATA
    UPDATE_GRID_CELLS

• Reducer structure:
    const initDataReducer = (state = initialState, action) => {
        console.log("\n== initDataReducer ==");
        switch (action.type) {
            case ADD_TIMES:
                console.log("-- ADD_TIMES --");
                return { ...state, times: [...state.times, action.payload] };
            }
            ...
        }
    export default initDataReducer;

• splitting reducers to handle only changing parts of state:
    function reducer(state = {}, action) {
        return {
            a: doSomethingWithA(state.a, action),
            b: processB(state.b, action),
            c: c(state.c, action)
        }
    }

• Example Actions:
    export const ADD_TODO = 'ADD_TODO'
    export const TOGGLE_TODO = 'TOGGLE_TODO'
    export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'
     
    export const VisibilityFilters = {
        SHOW_ALL: 'SHOW_ALL',
        SHOW_COMPLETED: 'SHOW_COMPLETED',
        SHOW_ACTIVE: 'SHOW_ACTIVE'
    }
    export function addTodo(text) {
        return {
            type: ADD_TODO,
            text }
    }
    export function toggleTodo(index) {
        return {
            type: TOGGLE_TODO,
            index }
    }     
    export function setVisibilityFilter(filter) {
        return {
            type: SET_VISIBILITY_FILTER,
            filter }
    }

• Example reducers:
    import { combineReducers } from 'redux'
    import { ADD_TODO, TOGGLE_TODO, SET_VISIBILITY_FILTER, VisibilityFilters } from './actions'
    const { SHOW_ALL } = VisibilityFilters
     
    function visibilityFilter(state = SHOW_ALL, action) {
      switch (action.type) {
        case SET_VISIBILITY_FILTER:
          return action.filter
        default:
          return state
      }
    }
     
    function todos(state = [], action) {
      switch (action.type) {
        case ADD_TODO:
          return [
            ...state,
            {
              text: action.text,
              completed: false
            }
          ]
        case TOGGLE_TODO:
          return state.map((todo, index) => {
            if (index === action.index) {
              return Object.assign({}, todo, {
                completed: !todo.completed
              })
            }
            return todo
          })
        default:
          return state
      }
    }
     
    const todoApp = combineReducers({
      visibilityFilter,
      todos
    })
     
    export default todoApp;

• Calendar reducers:

    const addData = (state = initialState, action) => {
        console.log("\n== addData ==");
        console.log("state:", state);
        console.log("action:", action);

        switch (action.type) {
            case ADD_TIMES:
            console.log("-- ADD_TIMES --");
            return { ...state, times: [...state.times, action.payload] };

            case ADD_DATES:
            console.log("-- ADD_DATES --");
            return { ...state, dates: [...state.dates, action.payload] };

            case ADD_ROOMS:
            console.log("-- ADD_ROOMS --");
            return { ...state, rooms: [...state.rooms, action.payload] };
            default:
            return state;
        }
    }
    export default addData;


// ======= add child components to existing parent =======
    var App = React.createClass({

        getInitialState: function(){
            return [
                {id:1,name:"Some Name"}
            ]
        },

        addChild: function() {
            // State change will cause component re-render
            this.setState(this.state.concat([
                {id:2,name:"Another Name"}
            ]))
        }

        render: function() {
            return (
                <div>
                    <h1>App main component! </h1>
                    <button onClick={this.addChild}>Add component</button>
                    {
                        this.state.map((item) => (
                            <SampleComponent key={item.id} name={item.name}/>
                        ))
                    }
                </div>
            );
        }
    });


// ======= dependencies =======
• Redux-Thunk enables work with async, functions, promises and other advanced features






///
